def binary_search(N, condition):
    l, r = 0, 0.45
    while r - l > 1e-8:
        m = (l+r) / 2
        a = m
        for i in range(1, N):
            a = a + (a/i)**2
        
        if callable(condition): res = condition(a)
        else: res = condition

        if a > res: r = m
        else: l = m

    print(N, m)

def dynamic(a):
    # 这个函数一定是单调的吗？不然二分搜索不到结果
    # e.g. N = 1
    # (π coth(sqrt(a) π) a^(3/2) + 3 a + π coth(sqrt(a) π) sqrt(a) + 1)/(2 a (a + 1)) - 1/(a+1) - 1/a = 1/a - 1
    # 左边倒的确是单减
    def coth(x):
        return math.cosh(x) / math.sinh(x) 

    partial_sum = (math.pi * coth(math.sqrt(a) * math.pi) * a**(3/2) + 3 * a \
            + math.pi * coth(math.sqrt(a) * math.pi) * math.sqrt(a) + 1) \
            / (2 * a * (a + 1)) \
            - sum([1/(a + i**2) for i in range(-1, N)])
    return 1 / (1 + partial_sum)

import math
for mi in range(6):
    N = 10**mi
    # 方法1、
    # condition = (N-1) / N
    # condition = (N**2 - 1) / (N**2 + N)
    # condition = (N**2 - N) / (N**2)
    # 1 6.7055225372314455e-09
    # 10 0.4347021348774433
    # 100 0.436044044047594
    # 1000 0.4360549606382847
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # condition = (N-0.5) / (N+0.5)
    # condition = (N**2 - 0.5*N) / (N**2 + 0.5*N)
    # condition = (N**2 - 0.25) / (N**2 + N + 0.25)
    # 1 0.3333333291113377
    # 10 0.4359576500952243
    # 100 0.43605498746037485
    # 1000 0.4360550679266453
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # condition = (N**2) / (N**2+N+1)
    # N / N+1+eps
    # 1 0.3333333291113377
    # 10 0.4349400602281094
    # 100 0.43604425862431523
    # 1000 0.4360549606382847
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # (N**2 - 0.5*N - 0.25) / (N**2 + 0.5*N + 0.25)
    # 1 0.14285714104771613
    # 10 0.43476488515734674
    # 100 0.43604409769177427
    # 1000 0.4360549606382847
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453
    # 1000000 0.4360550679266453

    # condition = (N**2) / (N**2+N+0.5) # 最准
    # 1 0.3999999962747097
    # 10 0.4360143385827541
    # 100 0.4360550411045551
    # 1000 0.4360550679266453
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    condition = (N**2-1/6) / (N**2+N+1/3)
    # 1 0.35714285597205164
    # 10 0.4359765730798244
    # 100 0.43605500087141996
    # 1000 0.4360550679266453
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # ---------------------------------------------

    # 方法2、
    # condition = 1 / (1 + math.pi**2/6 - sum([1/(i**2) for i in range(1, N)]))
    # 1 0.37808125242590906
    # 10 0.43597850427031515
    # 100 0.43605500087141996
    # 1000 0.4360550679266453
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # condition = dynamic
    # 1 0.43287273421883576 # 这是只保留第一项时精确度相对最高的
    # 10 0.43605344519019124
    # 100 0.4360550679266453
    # 1000 0.4360550679266453
    # 10000 0.4360550679266453
    # 100000 0.4360550679266453

    # 方法3、反号了，这是在逼近上界
    condition = math.exp(sum([math.log(1+1/(i**2+i+0.5)) for i in range(1, N)])) / (6.687/3)
    # 1 0.4486316777765751
    # 10 0.4360630072653293
    # 100 0.43606129065155974
    # 1000 0.4360612370073795
    # 10000 0.4360612370073795
    # 100000 0.4360612370073795

    binary_search(N, condition)


"""
excel:
    # condition = (N-1) / N # condition = (N-0.5) / (N+0.5) # condition = (N**2) / (N**2+N+1)   # condition = (N**2) / (N**2+N+0.5)   condition = (N**2-1/6) / (N**2+N+1/3) # condition = 1 / (1 + math.pi**2/6 - sum([1/(i**2) for i in range(1, N)])) # condition = dynamic
1   6.71E-09    0.333333329 0.333333329 0.399999996 0.357142856 0.378081252 0.432872734
10  0.434702135 0.43595765  0.43494006  0.436014339 0.435976573 0.435978504 0.436053445
100 0.436044044 0.436054987 0.436044259 0.436055041 0.436055001 0.436055001 0.436055068
1000    0.436054961 0.436055068 0.436054961 0.436055068 0.436055068 0.436055068 0.436055068
10000   0.436055068 0.436055068 0.436055068 0.436055068 0.436055068 0.436055068 0.436055068
100000  0.436055068 0.436055068 0.436055068 0.436055068 0.436055068 0.436055068 0.436055068
"""